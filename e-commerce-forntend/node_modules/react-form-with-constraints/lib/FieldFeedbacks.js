import * as React from 'react';
import * as PropTypes from 'prop-types';
import { FormWithConstraints } from './FormWithConstraints';
import { withValidateFieldEventEmitter } from './withValidateFieldEventEmitter';
class FieldFeedbacksComponent extends React.PureComponent {
}
export class FieldFeedbacks extends withValidateFieldEventEmitter(FieldFeedbacksComponent) {
    constructor(props, context) {
        super(props, context);
        this.fieldFeedbackKeyCounter = 0;
        this.validate = async (input) => {
            const { form, fieldFeedbacks: fieldFeedbacksParent } = this.context;
            let validations;
            if (input.name === this.fieldName) {
                const field = form.fieldsStore.getField(this.fieldName);
                if (fieldFeedbacksParent && (fieldFeedbacksParent.props.stop === 'first' && field.hasFeedbacks(fieldFeedbacksParent.key) ||
                    fieldFeedbacksParent.props.stop === 'first-error' && field.hasErrors(fieldFeedbacksParent.key) ||
                    fieldFeedbacksParent.props.stop === 'first-warning' && field.hasWarnings(fieldFeedbacksParent.key) ||
                    fieldFeedbacksParent.props.stop === 'first-info' && field.hasInfos(fieldFeedbacksParent.key))) {
                }
                else {
                    validations = await this._validate(input);
                }
            }
            return validations;
        };
        const { form, fieldFeedbacks: fieldFeedbacksParent } = context;
        this.key = fieldFeedbacksParent
            ? fieldFeedbacksParent.computeFieldFeedbackKey()
            : form.computeFieldFeedbacksKey();
        if (fieldFeedbacksParent) {
            this.fieldName = fieldFeedbacksParent.fieldName;
            if (props.for !== undefined) {
                throw new Error("FieldFeedbacks cannot have a parent and a 'for' prop");
            }
        }
        else {
            if (props.for === undefined) {
                throw new Error("FieldFeedbacks cannot be without parent and without 'for' prop");
            }
            else {
                this.fieldName = props.for;
            }
        }
    }
    getChildContext() {
        return {
            fieldFeedbacks: this
        };
    }
    computeFieldFeedbackKey() {
        return `${this.key}.${this.fieldFeedbackKeyCounter++}`;
    }
    addFieldFeedback() {
        return this.computeFieldFeedbackKey();
    }
    componentDidMount() {
        const { form, fieldFeedbacks: fieldFeedbacksParent } = this.context;
        form.fieldsStore.addField(this.fieldName);
        const parent = fieldFeedbacksParent || form;
        parent.addValidateFieldEventListener(this.validate);
    }
    componentWillUnmount() {
        const { form, fieldFeedbacks: fieldFeedbacksParent } = this.context;
        form.fieldsStore.removeField(this.fieldName);
        const parent = fieldFeedbacksParent || form;
        parent.removeValidateFieldEventListener(this.validate);
    }
    async _validate(input) {
        const arrayOfArrays = await this.emitValidateFieldEvent(input);
        const validations = arrayOfArrays.flat(Infinity);
        return validations;
    }
    render() {
        const { children } = this.props;
        return children !== undefined ? children : null;
    }
}
FieldFeedbacks.defaultProps = {
    stop: 'first-error'
};
FieldFeedbacks.contextTypes = {
    form: PropTypes.instanceOf(FormWithConstraints).isRequired,
    fieldFeedbacks: PropTypes.instanceOf(FieldFeedbacks)
};
FieldFeedbacks.childContextTypes = {
    fieldFeedbacks: PropTypes.instanceOf(FieldFeedbacks).isRequired
};
//# sourceMappingURL=FieldFeedbacks.js.map