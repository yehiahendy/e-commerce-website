{"version":3,"file":"react-form-with-constraints.production.min.js","sources":["../src/assert.ts","../src/EventEmitter.ts","../src/FieldFeedbackType.ts","../src/Field.ts","../src/clearArray.ts","../src/FieldsStore.ts","../src/InputElement.ts","../src/withFieldDidResetEventEmitter.ts","../src/withFieldDidValidateEventEmitter.ts","../src/withFieldWillValidateEventEmitter.ts","../src/withValidateFieldEventEmitter.ts","../src/FormWithConstraints.tsx","../src/notUndefined.ts","../src/FieldFeedbacks.tsx","../src/Async.tsx","../src/FieldFeedbackWhenValid.tsx","../src/FieldFeedback.tsx","../src/Input.tsx","../src/deepForEach.ts"],"sourcesContent":["// https://devblogs.microsoft.com/typescript/announcing-typescript-3-7/#assertion-functions\nexport function assert(condition: boolean, message?: string): asserts condition {\n  // error TS2569: Type 'IArguments' is not an array type or a string type.\n  // Use compiler option '--downlevelIteration' to allow iterating of iterators.\n  //console.assert(...arguments);\n\n  if (message === undefined) {\n    console.assert(condition);\n  } else {\n    console.assert(condition, message);\n  }\n}\n","import { assert } from './assert';\n\n// FIXME [Proposal: Variadic Kinds -- Give specific types to variadic functions](https://github.com/Microsoft/TypeScript/issues/5453)\n\ntype Listener<Args extends any[], ReturnType> = (...args: Args) => ReturnType | Promise<ReturnType>;\n\nexport class EventEmitter<ListenerArgs extends any[], ListenerReturnType> {\n  listeners = new Map<string, Listener<ListenerArgs, ListenerReturnType>[]>();\n\n  emitSync(eventName: string, ...args: ListenerArgs) {\n    const listeners = this.getListeners(eventName);\n    const ret = new Array<ListenerReturnType>();\n    listeners.forEach(listener => ret.push(listener(...args) as ListenerReturnType));\n    return ret;\n  }\n\n  async emitAsync(eventName: string, ...args: ListenerArgs) {\n    const listeners = this.getListeners(eventName);\n    const ret = new Array<ListenerReturnType>();\n    for (let i = 0; i < listeners.length; i++) {\n      // Why await? Two cases:\n      // - listener does not return a Promise:\n      //   => await changes nothing: the next listener call happens when the current one is done\n      // - listener returns a Promise:\n      //   => wait for the listener call to finish (e.g listeners are executed in sequence),\n      //      without we would call each listener without waiting for their results\n      // eslint-disable-next-line no-await-in-loop\n      ret.push(await listeners[i](...args));\n    }\n    return ret;\n  }\n\n  private getListeners(eventName: string) {\n    const listeners = this.listeners.get(eventName);\n\n    // Assert disabled: an event can be emitted even without listeners\n    //assert(listeners !== undefined, `Unknown event '${eventName}'`);\n\n    if (listeners !== undefined) {\n      assert(listeners.length > 0, `No listener for event '${eventName}'`);\n      return listeners;\n    }\n    return [];\n  }\n\n  addListener(eventName: string, listener: Listener<ListenerArgs, ListenerReturnType>) {\n    if (!this.listeners.has(eventName)) this.listeners.set(eventName, []);\n    const listeners = this.listeners.get(eventName)!;\n    assert(!listeners.includes(listener), `Listener already added for event '${eventName}'`);\n    listeners.push(listener);\n  }\n\n  // [\"removeListener() will remove, at most, one instance of a listener from the listener array.\n  // If any single listener has been added multiple times to the listener array for the specified eventName,\n  // then removeListener() must be called multiple times to remove each instance.\"](https://nodejs.org/api/events.html#events_emitter_removelistener_eventname_listener)\n  removeListener(eventName: string, listener: Listener<ListenerArgs, ListenerReturnType>) {\n    const listeners = this.listeners.get(eventName);\n    assert(listeners !== undefined, `Unknown event '${eventName}'`);\n\n    const index = listeners.lastIndexOf(listener);\n    assert(index > -1, `Listener not found for event '${eventName}'`);\n    listeners.splice(index, 1);\n\n    if (listeners.length === 0) this.listeners.delete(eventName);\n  }\n}\n","// Not inside FieldFeedback to avoid a circular dependency:\n// Async.js -> FormWithConstraints.js -> FieldsStore.js -> Field.js -> FieldFeedback.js -> Async.js\n// Field.js -> FieldFeedback.js -> FormWithConstraints.js -> FieldsStore.js -> Field.js\n// FieldFeedback.js -> FormWithConstraints.js -> FieldsStore.js -> Field.js -> FieldFeedback.js\n// FieldFeedbackWhenValid.js -> FormWithConstraints.js -> FieldsStore.js -> Field.js -> FieldFeedback.js -> FieldFeedbackWhenValid.js\n// FieldFeedbacks.js -> FormWithConstraints.js -> FieldsStore.js -> Field.js -> FieldFeedback.js -> FieldFeedbacks.js\n// FieldsStore.js -> Field.js -> FieldFeedback.js -> FormWithConstraints.js -> FieldsStore.js\n// FormWithConstraints.js -> FieldsStore.js -> Field.js -> FieldFeedback.js -> FormWithConstraints.js\n//\n// Detected thanks to https://github.com/aackerman/circular-dependency-plugin\n//\n// This caused an error with PropTypes:\n// `Warning: Failed context type: Right-hand side of 'instanceof' is not an object`\n// with `form: PropTypes.instanceOf(FormWithConstraints).isRequired` inside FieldFeedbacks\nexport enum FieldFeedbackType {\n  Error = 'error',\n  Warning = 'warning',\n  Info = 'info',\n  WhenValid = 'whenValid'\n}\n","import { clearArray } from './clearArray';\nimport { FieldFeedbackType } from './FieldFeedbackType';\nimport { FieldFeedbackValidation } from './FieldFeedbackValidation';\nimport { HTMLInput, TextInput } from './InputElement';\n\n// Field is a better name than Input, [Django Form fields](https://docs.djangoproject.com/en/1.11/ref/forms/fields/)\nexport class Field {\n  public readonly validations: FieldFeedbackValidation[] = [];\n\n  // Can be useful for the user to get the DOM element\n  // https://github.com/tkrotoff/react-form-with-constraints/issues/41\n  //\n  // Populated by FormWithConstraints.validateField()\n  //\n  // Cannot be set as readonly :/\n  public element?: HTMLInput | TextInput;\n\n  constructor(public readonly name: string) {}\n\n  addOrReplaceValidation(validation: FieldFeedbackValidation) {\n    // [Update if exists or add new element to array of objects](https://stackoverflow.com/a/49375465/990356)\n    const i = this.validations.findIndex(_validation => _validation.key === validation.key);\n    if (i > -1) this.validations[i] = validation;\n    else this.validations.push(validation);\n  }\n\n  clearValidations() {\n    clearArray(this.validations);\n  }\n\n  hasFeedbacksOfType(type: FieldFeedbackType, fieldFeedbacksKey?: string) {\n    return this.validations.some(\n      fieldFeedback =>\n        (fieldFeedbacksKey === undefined ||\n          fieldFeedback.key.startsWith(`${fieldFeedbacksKey}.`)) &&\n        fieldFeedback.type === type &&\n        fieldFeedback.show === true\n    );\n  }\n\n  hasErrors(fieldFeedbacksKey?: string) {\n    return this.hasFeedbacksOfType(FieldFeedbackType.Error, fieldFeedbacksKey);\n  }\n\n  hasWarnings(fieldFeedbacksKey?: string) {\n    return this.hasFeedbacksOfType(FieldFeedbackType.Warning, fieldFeedbacksKey);\n  }\n\n  hasInfos(fieldFeedbacksKey?: string) {\n    return this.hasFeedbacksOfType(FieldFeedbackType.Info, fieldFeedbacksKey);\n  }\n\n  hasFeedbacks(fieldFeedbacksKey?: string) {\n    return (\n      this.hasErrors(fieldFeedbacksKey) ||\n      this.hasWarnings(fieldFeedbacksKey) ||\n      this.hasInfos(fieldFeedbacksKey)\n    );\n  }\n\n  isValid() {\n    return !this.hasErrors();\n  }\n}\n","// [How do I empty an array in JavaScript?](https://stackoverflow.com/q/1232040)\nexport function clearArray<T>(array: T[]) {\n  while (array.length) {\n    array.pop();\n  }\n}\n","import { assert } from './assert';\nimport { EventEmitter } from './EventEmitter';\nimport { Field } from './Field';\n\nexport enum FieldEvent {\n  Added = 'FIELD_ADDED',\n  Removed = 'FIELD_REMOVED'\n}\n\nexport class FieldsStore extends EventEmitter<[Field | string], void> {\n  readonly fields = new Array<Field>();\n\n  getField(fieldName: string) {\n    const fields = this.fields.filter(_field => _field.name === fieldName);\n    //assert(fields.length === 1, `Unknown field '${fieldName}'`);\n    return fields.length === 1 ? fields[0] : undefined;\n  }\n\n  addField(fieldName: string) {\n    const fields = this.fields.filter(_field => _field.name === fieldName);\n    assert(\n      fields.length === 0 || fields.length === 1,\n      `Cannot have more than 1 field matching '${fieldName}'`\n    );\n\n    if (fields.length === 0) {\n      const newField = new Field(fieldName);\n      this.fields.push(newField);\n      this.emitSync(FieldEvent.Added, newField);\n    } else {\n      // We can have multiple FieldFeedbacks for the same field,\n      // thus addField() can be called multiple times\n    }\n  }\n\n  removeField(fieldName: string) {\n    // eslint-disable-next-line unicorn/prefer-array-find\n    const fields = this.fields.filter(_field => _field.name === fieldName);\n\n    // We can have multiple FieldFeedbacks for the same field,\n    // thus removeField() can be called multiple times\n    //assert(fields.length === 1, `Unknown field '${fieldName}'`);\n\n    const index = this.fields.indexOf(fields[0]);\n    if (index > -1) {\n      this.fields.splice(index, 1);\n      this.emitSync(FieldEvent.Removed, fieldName);\n    }\n  }\n\n  isValid() {\n    return this.fields.every(field => field.isValid());\n  }\n\n  hasFeedbacks() {\n    return this.fields.some(field => field.hasFeedbacks());\n  }\n}\n","// [React Native TextInput](https://facebook.github.io/react-native/docs/textinput.html)\n// Here so we don't have to \"import { TextInput } from 'react-native'\" and depend on React Native\nexport interface TextInput {\n  //value?: string; // Always undefined, use instead props.value\n  props: {\n    name: string;\n    value?: string;\n  };\n}\n\n// Cannot clone ValidityState using JSON.parse(JSON.stringify(input.validity)),\n// results in an empty object ({}) under Chrome 66, Firefox 60 and Safari 10.1.2\n// so let's manually clone it.\nexport class IValidityState implements ValidityState {\n  readonly badInput: boolean;\n  readonly customError: boolean;\n  readonly patternMismatch: boolean;\n  readonly rangeOverflow: boolean;\n  readonly rangeUnderflow: boolean;\n  readonly stepMismatch: boolean;\n  readonly tooLong: boolean;\n  readonly tooShort: boolean;\n  readonly typeMismatch: boolean;\n  readonly valid: boolean;\n  readonly valueMissing: boolean;\n\n  constructor(validity: ValidityState) {\n    this.badInput = validity.badInput;\n    this.customError = validity.customError;\n    this.patternMismatch = validity.patternMismatch;\n    this.rangeOverflow = validity.rangeOverflow;\n    this.rangeUnderflow = validity.rangeUnderflow;\n    this.stepMismatch = validity.stepMismatch;\n    this.tooLong = validity.tooLong;\n    this.tooShort = validity.tooShort;\n    this.typeMismatch = validity.typeMismatch;\n    this.valid = validity.valid;\n    this.valueMissing = validity.valueMissing;\n  }\n}\n\n// Type for Field.element\nexport type HTMLInput = HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement;\n\n// Minimum interface accepted by validateFields() and friends\nexport interface IHTMLInput {\n  readonly name: string;\n  readonly type: string; // Not needed internally, can be text, radio...\n  readonly value: string;\n\n  // validity and validationMessage available for (lib.dom.d.ts):\n  // HTMLButtonElement, HTMLFieldSetElement, HTMLInputElement, HTMLObjectElement,\n  // HTMLOutputElement, HTMLSelectElement, HTMLTextAreaElement\n  // ValidityState is supported by IE >= 10\n  readonly validity: IValidityState;\n  readonly validationMessage: string;\n}\n\nexport function isHTMLInput(input: IHTMLInput | TextInput): input is IHTMLInput {\n  return (input as any).props === undefined;\n}\n\n// Need to duplicate the input when the user changes rapidly the input\n// otherwise we will treat only the last input value instead of every input value change\n// Cannot be named Field or Input: already taken\nexport class InputElement implements IHTMLInput {\n  readonly name: string;\n  readonly type: string;\n  readonly value: string;\n  readonly validity: IValidityState;\n  readonly validationMessage: string;\n\n  constructor(input: IHTMLInput | TextInput) {\n    if (isHTMLInput(input)) {\n      this.name = input.name;\n      this.type = input.type;\n      this.value = input.value;\n\n      // Solution 1: no clone, then .mock.calls never ends with ValidityState inside FormWithConstraints.test.tsx in v0.8\n      //this.validity = input.validity;\n\n      // Solution 2: JSON does not work to clone ValidityState (results in an empty object)\n      //this.validity = JSON.parse(JSON.stringify(input.validity));\n\n      // Solution 3: manually clone ValidityState\n      this.validity = new IValidityState(input.validity as ValidityState);\n\n      this.validationMessage = input.validationMessage;\n    } else {\n      this.name = input.props.name;\n      this.type = undefined as any;\n      this.value = input.props.value!; // Tested: TextInput props.value is always a string and never undefined (empty string instead)\n      this.validity = undefined as any;\n      this.validationMessage = undefined as any;\n    }\n  }\n}\n","import { Constructor } from './Constructor';\nimport { EventEmitter } from './EventEmitter';\nimport { Field } from './Field';\n\nexport const FieldDidResetEvent = 'FIELD_DID_RESET_EVENT';\n\n// [TypeScript 2.2 Support for Mix-in classes](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html)\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function withFieldDidResetEventEmitter<TBase extends Constructor<{}>>(Base: TBase) {\n  type ListenerArg = Field;\n  type ListenerReturnType = void;\n  type Listener = (field: ListenerArg) => ListenerReturnType;\n\n  return class ResetFieldEvenEmitter extends Base {\n    fieldDidResetEventEmitter = new EventEmitter<[ListenerArg], ListenerReturnType>();\n\n    emitFieldDidResetEvent(field: Field) {\n      return this.fieldDidResetEventEmitter.emitSync(FieldDidResetEvent, field);\n    }\n\n    addFieldDidResetEventListener(listener: Listener) {\n      this.fieldDidResetEventEmitter.addListener(FieldDidResetEvent, listener);\n    }\n\n    removeFieldDidResetEventListener(listener: Listener) {\n      this.fieldDidResetEventEmitter.removeListener(FieldDidResetEvent, listener);\n    }\n  };\n}\n","import { Constructor } from './Constructor';\nimport { EventEmitter } from './EventEmitter';\nimport { Field } from './Field';\n\nexport const FieldDidValidateEvent = 'FIELD_DID_VALIDATE_EVENT';\n\n// [TypeScript 2.2 Support for Mix-in classes](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html)\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function withFieldDidValidateEventEmitter<TBase extends Constructor<{}>>(Base: TBase) {\n  type ListenerArg = Field;\n  type ListenerReturnType = void;\n  type Listener = (field: ListenerArg) => ListenerReturnType;\n\n  return class FieldDidValidateEventEmitter extends Base {\n    fieldDidValidateEventEmitter = new EventEmitter<[ListenerArg], ListenerReturnType>();\n\n    emitFieldDidValidateEvent(field: Field) {\n      return this.fieldDidValidateEventEmitter.emitSync(FieldDidValidateEvent, field);\n    }\n\n    addFieldDidValidateEventListener(listener: Listener) {\n      this.fieldDidValidateEventEmitter.addListener(FieldDidValidateEvent, listener);\n    }\n\n    removeFieldDidValidateEventListener(listener: Listener) {\n      this.fieldDidValidateEventEmitter.removeListener(FieldDidValidateEvent, listener);\n    }\n  };\n}\n","import { Constructor } from './Constructor';\nimport { EventEmitter } from './EventEmitter';\n\nexport const FieldWillValidateEvent = 'FIELD_WILL_VALIDATE_EVENT';\n\n// [TypeScript 2.2 Support for Mix-in classes](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html)\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function withFieldWillValidateEventEmitter<TBase extends Constructor<{}>>(Base: TBase) {\n  type ListenerArg = string;\n  type ListenerReturnType = void;\n  type Listener = (fieldName: ListenerArg) => ListenerReturnType;\n\n  return class FieldWillValidateEventEmitter extends Base {\n    fieldWillValidateEventEmitter = new EventEmitter<[ListenerArg], ListenerReturnType>();\n\n    emitFieldWillValidateEvent(fieldName: string) {\n      return this.fieldWillValidateEventEmitter.emitSync(FieldWillValidateEvent, fieldName);\n    }\n\n    addFieldWillValidateEventListener(listener: Listener) {\n      this.fieldWillValidateEventEmitter.addListener(FieldWillValidateEvent, listener);\n    }\n\n    removeFieldWillValidateEventListener(listener: Listener) {\n      this.fieldWillValidateEventEmitter.removeListener(FieldWillValidateEvent, listener);\n    }\n  };\n}\n","import { Constructor } from './Constructor';\nimport { EventEmitter } from './EventEmitter';\nimport { InputElement } from './InputElement';\n\nexport const ValidateFieldEvent = 'VALIDATE_FIELD_EVENT';\n\n// [TypeScript 2.2 Support for Mix-in classes](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html)\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function withValidateFieldEventEmitter<ListenerReturnType, TBase extends Constructor<{}>>(\n  Base: TBase\n) {\n  type ListenerArg = InputElement;\n  type Listener = (input: ListenerArg) => ListenerReturnType | Promise<ListenerReturnType>;\n\n  return class ValidateFieldEventEmitter extends Base {\n    validateFieldEventEmitter = new EventEmitter<[ListenerArg], ListenerReturnType>();\n\n    emitValidateFieldEvent(input: InputElement) {\n      return this.validateFieldEventEmitter.emitAsync(ValidateFieldEvent, input);\n    }\n\n    addValidateFieldEventListener(listener: Listener) {\n      this.validateFieldEventEmitter.addListener(ValidateFieldEvent, listener);\n    }\n\n    removeValidateFieldEventListener(listener: Listener) {\n      this.validateFieldEventEmitter.removeListener(ValidateFieldEvent, listener);\n    }\n  };\n}\n","import * as React from 'react';\nimport * as PropTypes from 'prop-types';\n\nimport { assert } from './assert';\nimport { Field } from './Field';\nimport { FieldFeedbackValidation } from './FieldFeedbackValidation';\nimport { FieldsStore } from './FieldsStore';\nimport { HTMLInput, IHTMLInput, InputElement, TextInput } from './InputElement';\nimport { notUndefined } from './notUndefined';\nimport { withFieldDidResetEventEmitter } from './withFieldDidResetEventEmitter';\nimport { withFieldDidValidateEventEmitter } from './withFieldDidValidateEventEmitter';\nimport { withFieldWillValidateEventEmitter } from './withFieldWillValidateEventEmitter';\nimport { withValidateFieldEventEmitter } from './withValidateFieldEventEmitter';\n\nexport interface FormWithConstraintsChildContext {\n  form: FormWithConstraints;\n}\n\nexport interface FormWithConstraintsProps extends React.FormHTMLAttributes<HTMLFormElement> {}\n\nclass FormWithConstraintsComponent extends React.PureComponent<FormWithConstraintsProps> {}\nexport class FormWithConstraints\n  extends withFieldDidResetEventEmitter(\n    withFieldWillValidateEventEmitter(\n      withFieldDidValidateEventEmitter(\n        withValidateFieldEventEmitter<\n          // FieldFeedback returns FieldFeedbackValidation\n          // Async returns FieldFeedbackValidation[] | undefined\n          // FieldFeedbacks returns (FieldFeedbackValidation | undefined)[] | undefined\n          FieldFeedbackValidation | (FieldFeedbackValidation | undefined)[] | undefined,\n          typeof FormWithConstraintsComponent\n        >(FormWithConstraintsComponent)\n      )\n    )\n  )\n  implements React.ChildContextProvider<FormWithConstraintsChildContext> {\n  static childContextTypes: React.ValidationMap<FormWithConstraintsChildContext> = {\n    form: PropTypes.instanceOf(FormWithConstraints).isRequired\n  };\n  getChildContext(): FormWithConstraintsChildContext {\n    return {\n      form: this\n    };\n  }\n\n  // Could be named innerRef instead, https://github.com/ant-design/ant-design/issues/5489#issuecomment-332208652\n  private form: HTMLFormElement | null = null;\n\n  fieldsStore = new FieldsStore();\n\n  private fieldFeedbacksKeyCounter = 0;\n  computeFieldFeedbacksKey() {\n    return `${this.fieldFeedbacksKeyCounter++}`;\n  }\n\n  /**\n   * Validates the given fields, either HTMLInputElements or field names.\n   * If called without arguments, validates all fields ($('[name]')).\n   */\n  validateFields(...inputsOrNames: Array<IHTMLInput | string>) {\n    return this._validateFields(/* forceValidateFields */ true, ...inputsOrNames);\n  }\n\n  // TODO To be removed in the future?\n  validateForm() {\n    return this.validateFieldsWithoutFeedback();\n  }\n\n  /**\n   * Validates fields without feedback only.\n   */\n  validateFieldsWithoutFeedback(...inputsOrNames: Array<IHTMLInput | string>) {\n    return this._validateFields(/* forceValidateFields */ false, ...inputsOrNames);\n  }\n\n  private async _validateFields(\n    forceValidateFields: boolean,\n    ...inputsOrNames: Array<IHTMLInput | string>\n  ) {\n    const fields = new Array<Readonly<Field>>();\n\n    const inputs = this.normalizeInputs(...inputsOrNames);\n\n    for (let i = 0; i < inputs.length; i++) {\n      const input = inputs[i];\n      // eslint-disable-next-line no-await-in-loop\n      const field = await this.validateField(\n        forceValidateFields,\n        new InputElement(input),\n        input as HTMLInput | TextInput\n      );\n      if (field !== undefined) fields.push(field);\n    }\n\n    return fields;\n  }\n\n  private async validateField(\n    forceValidateFields: boolean,\n    input: InputElement,\n\n    // We need to pass the native input separately instead of it being a property of InputElement\n    // otherwise react-form-with-constraints-native unit tests will crash\n    nativeInput: HTMLInput | TextInput\n  ) {\n    const fieldName = input.name;\n    const field = this.fieldsStore.getField(fieldName);\n\n    if (field === undefined) {\n      // Means the field (<input name=\"username\">) does not have a FieldFeedbacks\n      // so let's ignore this field\n    } else if (forceValidateFields || !field.hasFeedbacks()) {\n      field.element = nativeInput as HTMLInput | TextInput;\n      field.clearValidations();\n\n      this.emitFieldWillValidateEvent(fieldName);\n\n      const arrayOfArrays = await this.emitValidateFieldEvent(input);\n\n      // Internal check that everything is OK\n      // Can be temporary out of sync if the user rapidly change the input, in this case:\n      // emitFieldWillValidateEvent() returns the result of the first change while the store already contains the final validations\n      assert(\n        JSON.stringify(\n          (arrayOfArrays.flat(Infinity) as (\n            | FieldFeedbackValidation\n            | undefined\n          )[]).filter(fieldFeedback => notUndefined(fieldFeedback))\n        ) /* validationsFromEmitValidateFieldEvent */ ===\n          JSON.stringify(field.validations) /* validationsFromStore */,\n        `FieldsStore does not match emitValidateFieldEvent() result, did the user changed the input rapidly?`\n      );\n\n      this.emitFieldDidValidateEvent(field);\n    }\n\n    return field;\n  }\n\n  // If called without arguments, returns all fields ($('[name]'))\n  // Returns the inputs in the same order they were given\n  protected normalizeInputs(...inputsOrNames: Array<IHTMLInput | string>) {\n    let inputs;\n\n    if (inputsOrNames.length === 0) {\n      // [name] matches <input name=\"...\">, <select name=\"...\">, <button name=\"...\">, ...\n      // [Convert JavaScript NodeList to Array?](https://stackoverflow.com/a/33822526/990356)\n      // [...NodeList] vs Array.from(NodeList): the latter doesn't need downlevelIteration with IE\n      // eslint-disable-next-line unicorn/prefer-spread\n      inputs = Array.from(this.form!.querySelectorAll<HTMLInputElement>('[name]'));\n\n      // Remove elements without ValidityState, example:\n      // <iframe src=\"https://www.google.com/recaptcha...\" name=\"a-49ekipqfmwsv\">\n      // Without this check, possible crash inside InputElement is \"TypeError: Cannot read property 'badInput' of undefined\"\n      //\n      // ValidityState is available for (lib.dom.d.ts):\n      // HTMLButtonElement, HTMLFieldSetElement, HTMLInputElement, HTMLObjectElement,\n      // HTMLOutputElement, HTMLSelectElement, HTMLTextAreaElement\n      //\n      // ValidityState is supported by IE >= 10\n      inputs = inputs.filter(input => input.validity !== undefined);\n\n      // Check we have unique names\n      inputs\n        .filter(input => input.type !== 'checkbox' && input.type !== 'radio')\n        .map(input => input.name)\n        .forEach((name, index, self) => {\n          if (self.indexOf(name) !== index) {\n            throw new Error(`Multiple elements matching '[name=\"${name}\"]' inside the form`);\n          }\n        });\n    } else {\n      inputs = inputsOrNames.map(input => {\n        if (typeof input === 'string') {\n          const query = `[name=\"${input}\"]`;\n\n          // [...NodeList] vs Array.from(NodeList): the latter doesn't need downlevelIteration with IE\n          // eslint-disable-next-line unicorn/prefer-spread\n          const elements = Array.from(this.form!.querySelectorAll<HTMLInputElement>(query));\n\n          // Checks\n\n          if (elements.filter(el => el.validity === undefined).length > 0) {\n            // Should not match something like\n            // <iframe src=\"https://www.google.com/recaptcha...\" name=\"a-49ekipqfmwsv\">\n            throw new Error(`'${query}' should match an <input>, <select> or <textarea>`);\n          }\n          if (elements.filter(el => el.type !== 'checkbox' && el.type !== 'radio').length > 1) {\n            throw new Error(`Multiple elements matching '${query}' inside the form`);\n          }\n          const element = elements[0];\n          if (element === undefined) {\n            throw new Error(`Could not find field '${query}' inside the form`);\n          }\n\n          return element;\n        }\n\n        return input;\n      });\n    }\n\n    return inputs;\n  }\n\n  // More like seemsToBeValid(): return true if fields are untouched\n  isValid() {\n    return this.fieldsStore.isValid();\n  }\n\n  hasFeedbacks() {\n    return this.fieldsStore.hasFeedbacks();\n  }\n\n  // TODO To be removed in the future?\n  reset() {\n    return this.resetFields();\n  }\n\n  resetFields(...inputsOrNames: Array<IHTMLInput | string>) {\n    const fields = new Array<Readonly<Field>>();\n\n    const inputs = this.normalizeInputs(...inputsOrNames);\n    inputs.forEach(input => {\n      const field = this.resetField(new InputElement(input));\n      if (field !== undefined) fields.push(field);\n    });\n\n    return fields;\n  }\n\n  private resetField(input: InputElement) {\n    const fieldName = input.name;\n    const field = this.fieldsStore.getField(fieldName);\n\n    if (field === undefined) {\n      // Means the field (<input name=\"username\">) does not have a FieldFeedbacks\n      // so let's ignore this field\n    } else {\n      field.clearValidations();\n      this.emitFieldDidResetEvent(field);\n    }\n\n    return field;\n  }\n\n  render() {\n    return <form ref={form => (this.form = form)} {...this.props} />;\n  }\n}\n","// [\"TypeScript static analysis is unable to track this behavior\"](https://codereview.stackexchange.com/a/138289/148847)\n// [TypeScript filter out nulls from an array](https://stackoverflow.com/q/43118692)\nexport function notUndefined<T>(value: T | undefined): value is T {\n  return value !== undefined;\n}\n","import * as React from 'react';\nimport * as PropTypes from 'prop-types';\n\nimport { FieldFeedbackValidation } from './FieldFeedbackValidation';\nimport { FormWithConstraints, FormWithConstraintsChildContext } from './FormWithConstraints';\nimport { InputElement } from './InputElement';\nimport { Nullable } from './Nullable';\nimport { withValidateFieldEventEmitter } from './withValidateFieldEventEmitter';\n\nexport interface FieldFeedbacksProps {\n  for?: string;\n\n  /**\n   * first-* => stops on the first * encountered\n   * no => shows everything\n   * Default is 'first-error'\n   */\n  stop: 'first' | 'first-error' | 'first-warning' | 'first-info' | 'no';\n}\n\n// Why Nullable? https://github.com/DefinitelyTyped/DefinitelyTyped/pull/27973\nexport type FieldFeedbacksContext = FormWithConstraintsChildContext &\n  Partial<Nullable<FieldFeedbacksChildContext>>;\n\nexport interface FieldFeedbacksChildContext {\n  fieldFeedbacks: FieldFeedbacks;\n}\n\nclass FieldFeedbacksComponent extends React.PureComponent<FieldFeedbacksProps> {}\nexport class FieldFeedbacks\n  extends withValidateFieldEventEmitter<\n    // FieldFeedback returns FieldFeedbackValidation\n    // Async returns FieldFeedbackValidation[] | undefined\n    // FieldFeedbacks returns (FieldFeedbackValidation | undefined)[]\n    FieldFeedbackValidation | (FieldFeedbackValidation | undefined)[] | undefined,\n    typeof FieldFeedbacksComponent\n  >(FieldFeedbacksComponent)\n  implements React.ChildContextProvider<FieldFeedbacksChildContext> {\n  static defaultProps: FieldFeedbacksProps = {\n    stop: 'first-error'\n  };\n\n  static contextTypes: React.ValidationMap<FieldFeedbacksContext> = {\n    form: PropTypes.instanceOf(FormWithConstraints).isRequired,\n    fieldFeedbacks: PropTypes.instanceOf(FieldFeedbacks)\n  };\n  context!: FieldFeedbacksContext;\n\n  static childContextTypes: React.ValidationMap<FieldFeedbacksChildContext> = {\n    fieldFeedbacks: PropTypes.instanceOf(FieldFeedbacks).isRequired\n  };\n  getChildContext(): FieldFeedbacksChildContext {\n    return {\n      fieldFeedbacks: this\n    };\n  }\n\n  // Tested: there is no conflict with React key prop (https://reactjs.org/docs/lists-and-keys.html)\n  readonly key: string; // '0', '1', '2'...\n\n  readonly fieldName: string; // Instead of reading props each time\n\n  constructor(props: FieldFeedbacksProps, context: FieldFeedbacksContext) {\n    super(props, context);\n\n    const { form, fieldFeedbacks: fieldFeedbacksParent } = context;\n\n    this.key = fieldFeedbacksParent\n      ? fieldFeedbacksParent.computeFieldFeedbackKey()\n      : form.computeFieldFeedbacksKey();\n\n    if (fieldFeedbacksParent) {\n      this.fieldName = fieldFeedbacksParent.fieldName;\n      if (props.for !== undefined) {\n        throw new Error(\"FieldFeedbacks cannot have a parent and a 'for' prop\");\n      }\n    } else {\n      if (props.for === undefined) {\n        throw new Error(\"FieldFeedbacks cannot be without parent and without 'for' prop\");\n      } else {\n        this.fieldName = props.for;\n      }\n    }\n  }\n\n  private fieldFeedbackKeyCounter = 0;\n  computeFieldFeedbackKey() {\n    return `${this.key}.${this.fieldFeedbackKeyCounter++}`;\n  }\n\n  addFieldFeedback() {\n    return this.computeFieldFeedbackKey();\n  }\n\n  componentDidMount() {\n    const { form, fieldFeedbacks: fieldFeedbacksParent } = this.context;\n\n    form.fieldsStore.addField(this.fieldName);\n\n    const parent = fieldFeedbacksParent || form;\n    parent.addValidateFieldEventListener(this.validate);\n  }\n\n  componentWillUnmount() {\n    const { form, fieldFeedbacks: fieldFeedbacksParent } = this.context;\n\n    form.fieldsStore.removeField(this.fieldName);\n\n    const parent = fieldFeedbacksParent || form;\n    parent.removeValidateFieldEventListener(this.validate);\n  }\n\n  validate = async (input: InputElement) => {\n    const { form, fieldFeedbacks: fieldFeedbacksParent } = this.context;\n\n    let validations;\n\n    // Ignore the event if it's not for us\n    if (input.name === this.fieldName) {\n      const field = form.fieldsStore.getField(this.fieldName)!;\n\n      // prettier-ignore\n      if (fieldFeedbacksParent && (\n          fieldFeedbacksParent.props.stop === 'first' && field.hasFeedbacks(fieldFeedbacksParent.key) ||\n          fieldFeedbacksParent.props.stop === 'first-error' && field.hasErrors(fieldFeedbacksParent.key) ||\n          fieldFeedbacksParent.props.stop === 'first-warning' && field.hasWarnings(fieldFeedbacksParent.key) ||\n          fieldFeedbacksParent.props.stop === 'first-info' && field.hasInfos(fieldFeedbacksParent.key))) {\n        // Do nothing\n      } else {\n        validations = await this._validate(input);\n      }\n    }\n\n    return validations;\n  };\n\n  async _validate(input: InputElement) {\n    const arrayOfArrays = await this.emitValidateFieldEvent(input);\n    const validations = arrayOfArrays.flat(Infinity) as (FieldFeedbackValidation | undefined)[];\n    return validations;\n  }\n\n  render() {\n    const { children } = this.props;\n    // https://codepen.io/tkrotoff/pen/yzKKdB\n    return children !== undefined ? children : null;\n  }\n}\n","import * as React from 'react';\nimport * as PropTypes from 'prop-types';\n\nimport { assert } from './assert';\nimport { FieldFeedbacks, FieldFeedbacksChildContext } from './FieldFeedbacks';\nimport { FieldFeedbackValidation } from './FieldFeedbackValidation';\nimport { FormWithConstraints, FormWithConstraintsChildContext } from './FormWithConstraints';\nimport { InputElement } from './InputElement';\nimport { withValidateFieldEventEmitter } from './withValidateFieldEventEmitter';\n\nexport enum Status {\n  None,\n  Pending,\n  Rejected,\n  Resolved\n}\n\nexport interface AsyncProps<T> {\n  promise: (value: string) => Promise<T>;\n  pending?: React.ReactNode;\n  then?: (value: T) => React.ReactNode;\n  catch?: (reason: any) => React.ReactNode;\n}\n\ninterface AsyncState<T> {\n  status: Status;\n  value?: T;\n}\n\nexport interface AsyncChildContext {\n  async: Async<any>;\n}\n\nexport type AsyncContext = FormWithConstraintsChildContext & FieldFeedbacksChildContext;\n\n// [Asynchronous form errors and messages in AngularJS](https://jaysoo.ca/2014/10/14/async-form-errors-and-messages-in-angularjs/)\n// [Support for asynchronous values (like Promises and Observables)](https://github.com/facebook/react/issues/6481)\n// https://github.com/capaj/react-promise\n// [How to render promises in React](https://gist.github.com/hex13/6d46f8b54631871ea8bf87576b635c49)\n// Cannot be inside a separated npm package since FieldFeedback needs to attach itself to Async\nclass AsyncComponent<T = any> extends React.PureComponent<AsyncProps<T>, AsyncState<T>> {}\nexport class Async<T>\n  extends withValidateFieldEventEmitter<\n    // FieldFeedback returns FieldFeedbackValidation\n    FieldFeedbackValidation,\n    typeof AsyncComponent\n  >(AsyncComponent)\n  implements React.ChildContextProvider<AsyncChildContext> {\n  static contextTypes: React.ValidationMap<AsyncContext> = {\n    form: PropTypes.instanceOf(FormWithConstraints).isRequired,\n    fieldFeedbacks: PropTypes.instanceOf(FieldFeedbacks).isRequired\n  };\n  context!: AsyncContext;\n\n  static childContextTypes: React.ValidationMap<AsyncChildContext> = {\n    async: PropTypes.instanceOf(Async).isRequired\n  };\n  getChildContext(): AsyncChildContext {\n    return {\n      async: this\n    };\n  }\n\n  state: AsyncState<T> = {\n    status: Status.None\n  };\n\n  componentDidMount() {\n    this.context.fieldFeedbacks.addValidateFieldEventListener(this.validate);\n  }\n\n  componentWillUnmount() {\n    this.context.fieldFeedbacks.removeValidateFieldEventListener(this.validate);\n  }\n\n  validate = (input: InputElement) => {\n    const { form, fieldFeedbacks } = this.context;\n\n    let validations;\n\n    const field = form.fieldsStore.getField(input.name)!;\n\n    if (\n      (fieldFeedbacks.props.stop === 'first' && field.hasFeedbacks(fieldFeedbacks.key)) ||\n      (fieldFeedbacks.props.stop === 'first-error' && field.hasErrors(fieldFeedbacks.key)) ||\n      (fieldFeedbacks.props.stop === 'first-warning' && field.hasWarnings(fieldFeedbacks.key)) ||\n      (fieldFeedbacks.props.stop === 'first-info' && field.hasInfos(fieldFeedbacks.key))\n    ) {\n      // Reset UI\n      this.setState({ status: Status.None });\n    } else {\n      validations = this._validate(input);\n    }\n\n    return validations;\n  };\n\n  async _validate(input: InputElement) {\n    this.setState({ status: Status.Pending });\n    try {\n      const value = await this.props.promise(input.value);\n      this.setState({ status: Status.Resolved, value });\n    } catch (e) {\n      this.setState({ status: Status.Rejected, value: e });\n    }\n\n    return this.emitValidateFieldEvent(input);\n  }\n\n  render() {\n    const { props, state } = this;\n    let element = null;\n\n    switch (state.status) {\n      case Status.None:\n        break;\n      case Status.Pending:\n        if (props.pending) element = props.pending;\n        break;\n      case Status.Resolved:\n        if (props.then) element = props.then(state.value);\n        break;\n      case Status.Rejected:\n        if (props.catch) element = props.catch(state.value);\n        break;\n      default:\n        assert(false, `Unknown status: '${state.status}'`);\n    }\n\n    return element;\n  }\n}\n","import * as React from 'react';\nimport * as PropTypes from 'prop-types';\n\nimport { Field } from './Field';\nimport { FieldFeedbackClasses } from './FieldFeedback';\nimport { FieldFeedbacks, FieldFeedbacksChildContext } from './FieldFeedbacks';\nimport { FormWithConstraints, FormWithConstraintsChildContext } from './FormWithConstraints';\n\nexport interface FieldFeedbackWhenValidBaseProps {}\n\nexport interface FieldFeedbackWhenValidProps\n  extends FieldFeedbackWhenValidBaseProps,\n    FieldFeedbackClasses,\n    React.HTMLAttributes<HTMLSpanElement> {}\n\ninterface FieldFeedbackWhenValidState {\n  fieldIsValid: boolean | undefined;\n}\n\nexport type FieldFeedbackWhenValidContext = FormWithConstraintsChildContext &\n  FieldFeedbacksChildContext;\n\nexport class FieldFeedbackWhenValid<\n  Props extends FieldFeedbackWhenValidBaseProps = FieldFeedbackWhenValidProps\n> extends React.Component<Props, FieldFeedbackWhenValidState> {\n  static contextTypes: React.ValidationMap<FieldFeedbackWhenValidContext> = {\n    form: PropTypes.instanceOf(FormWithConstraints).isRequired,\n    fieldFeedbacks: PropTypes.instanceOf(FieldFeedbacks).isRequired\n  };\n  context!: FieldFeedbackWhenValidContext;\n\n  state: FieldFeedbackWhenValidState = {\n    fieldIsValid: undefined\n  };\n\n  /* eslint-disable react/destructuring-assignment */\n\n  componentDidMount() {\n    this.context.form.addFieldWillValidateEventListener(this.fieldWillValidate);\n    this.context.form.addFieldDidValidateEventListener(this.fieldDidValidate);\n    this.context.form.addFieldDidResetEventListener(this.fieldDidReset);\n  }\n\n  componentWillUnmount() {\n    this.context.form.removeFieldWillValidateEventListener(this.fieldWillValidate);\n    this.context.form.removeFieldDidValidateEventListener(this.fieldDidValidate);\n    this.context.form.removeFieldDidResetEventListener(this.fieldDidReset);\n  }\n\n  fieldWillValidate = (fieldName: string) => {\n    // Ignore the event if it's not for us\n    if (fieldName === this.context.fieldFeedbacks.fieldName) {\n      this.setState({ fieldIsValid: undefined });\n    }\n  };\n\n  fieldDidValidate = (field: Field) => {\n    // Ignore the event if it's not for us\n    if (field.name === this.context.fieldFeedbacks.fieldName) {\n      this.setState({ fieldIsValid: field.isValid() });\n    }\n  };\n\n  fieldDidReset = (field: Field) => {\n    // Ignore the event if it's not for us\n    if (field.name === this.context.fieldFeedbacks.fieldName) {\n      this.setState({ fieldIsValid: undefined });\n    }\n  };\n\n  // Don't forget to update native/FieldFeedbackWhenValid.render()\n  render() {\n    const { style, ...otherProps } = (this.props as unknown) as FieldFeedbackWhenValidProps;\n\n    return this.state.fieldIsValid ? (\n      // <span style=\"display: block\"> instead of <div> so FieldFeedbackWhenValid can be wrapped inside a <p>\n      // otherProps before className because otherProps contains data-feedback\n      <span {...otherProps} style={{ display: 'block', ...style }} />\n    ) : null;\n  }\n\n  /* eslint-enable react/destructuring-assignment */\n}\n","import * as React from 'react';\nimport * as PropTypes from 'prop-types';\n\nimport { Async, AsyncChildContext } from './Async';\nimport { Field } from './Field';\nimport { FieldFeedbacks, FieldFeedbacksChildContext } from './FieldFeedbacks';\nimport { FieldFeedbackType } from './FieldFeedbackType';\nimport { FieldFeedbackValidation } from './FieldFeedbackValidation';\nimport { FieldFeedbackWhenValid } from './FieldFeedbackWhenValid';\nimport { FormWithConstraints, FormWithConstraintsChildContext } from './FormWithConstraints';\nimport { InputElement } from './InputElement';\nimport { Nullable } from './Nullable';\n\ntype WhenString =\n  | 'valid'\n  | '*'\n  | 'badInput' // input type=\"number\"\n  | 'patternMismatch' // pattern attribute\n  | 'rangeOverflow' // max attribute\n  | 'rangeUnderflow' // min attribute\n  | 'stepMismatch' // step attribute\n  | 'tooLong' // maxlength attribute\n  | 'tooShort' // minlength attribute\n  | 'typeMismatch' // input type=\"email\" or input type=\"url\"\n  | 'valueMissing'; // required attribute\ntype WhenFn = (value: string) => boolean;\ntype When = WhenString | WhenFn;\n\nexport interface FieldFeedbackClasses {\n  classes?: {\n    // FIXME Should not be declared \"?\" thanks to defaultProps?\n    [index: string]: string | undefined;\n    error?: string;\n    warning?: string;\n    info?: string;\n    whenValid?: string;\n  };\n}\n\nexport interface FieldFeedbackBaseProps {\n  when?: When; // FIXME Should not be declared \"?\" thanks to defaultProps?\n  error?: boolean;\n  warning?: boolean;\n  info?: boolean;\n}\n\nexport interface FieldFeedbackProps\n  extends FieldFeedbackBaseProps,\n    FieldFeedbackClasses,\n    React.HTMLAttributes<HTMLSpanElement> {}\n\ninterface FieldFeedbackState {\n  validation: FieldFeedbackValidation;\n\n  // Copy of input.validationMessage\n  // https://developer.mozilla.org/en/docs/Web/API/HTMLInputElement\n  // https://www.w3.org/TR/html51/sec-forms.html#the-constraint-validation-api\n  validationMessage: string;\n}\n\n// Why Nullable? https://github.com/DefinitelyTyped/DefinitelyTyped/pull/27973\nexport type FieldFeedbackContext = FormWithConstraintsChildContext &\n  FieldFeedbacksChildContext &\n  Partial<Nullable<AsyncChildContext>>;\n\nexport class FieldFeedback<\n  Props extends FieldFeedbackBaseProps = FieldFeedbackProps\n> extends React.Component<Props, FieldFeedbackState> {\n  static defaultProps: FieldFeedbackProps = {\n    when: () => true,\n    classes: {\n      error: 'error',\n      warning: 'warning',\n      info: 'info',\n      whenValid: 'when-valid'\n    }\n  };\n\n  static contextTypes: React.ValidationMap<FieldFeedbackContext> = {\n    form: PropTypes.instanceOf(FormWithConstraints).isRequired,\n    fieldFeedbacks: PropTypes.instanceOf(FieldFeedbacks).isRequired,\n    async: PropTypes.instanceOf(Async)\n  };\n  context!: FieldFeedbackContext;\n\n  // Tested: there is no conflict with React key prop (https://reactjs.org/docs/lists-and-keys.html)\n  readonly key: string; // '0.1', '1.0', '3.5'...\n\n  constructor(props: Props, context: FieldFeedbackContext) {\n    super(props, context);\n\n    this.key = context.fieldFeedbacks.addFieldFeedback();\n\n    const { error, warning, info, when } = props;\n\n    let type = FieldFeedbackType.Error; // Default is error\n    if (when === 'valid') type = FieldFeedbackType.WhenValid;\n    else if (warning) type = FieldFeedbackType.Warning;\n    else if (info) type = FieldFeedbackType.Info;\n\n    // Special case for when=\"valid\"\n    if (type === FieldFeedbackType.WhenValid && (error || warning || info)) {\n      throw new Error(\n        'Cannot have an attribute (error, warning...) with FieldFeedback when=\"valid\"'\n      );\n    }\n\n    // eslint-disable-next-line react/state-in-constructor\n    this.state = {\n      validation: {\n        key: this.key,\n        type,\n        show: undefined // undefined means the FieldFeedback was not checked\n      },\n      validationMessage: ''\n    };\n  }\n\n  componentDidMount() {\n    const { form, fieldFeedbacks, async } = this.context;\n\n    if (async) async.addValidateFieldEventListener(this.validate);\n    else fieldFeedbacks.addValidateFieldEventListener(this.validate);\n\n    form.addFieldDidResetEventListener(this.fieldDidReset);\n  }\n\n  componentWillUnmount() {\n    const { form, fieldFeedbacks, async } = this.context;\n\n    if (async) async.removeValidateFieldEventListener(this.validate);\n    else fieldFeedbacks.removeValidateFieldEventListener(this.validate);\n\n    form.removeFieldDidResetEventListener(this.fieldDidReset);\n  }\n\n  validate = (input: InputElement) => {\n    const { when } = this.props;\n    const { form, fieldFeedbacks } = this.context;\n\n    const field = form.fieldsStore.getField(input.name)!;\n\n    // Copy state so we don't modify it directly (use of setState() instead)\n    // eslint-disable-next-line react/no-access-state-in-setstate, react/destructuring-assignment\n    const validation = { ...this.state.validation };\n\n    if (\n      (fieldFeedbacks.props.stop === 'first' && field.hasFeedbacks(fieldFeedbacks.key)) ||\n      (fieldFeedbacks.props.stop === 'first-error' && field.hasErrors(fieldFeedbacks.key)) ||\n      (fieldFeedbacks.props.stop === 'first-warning' && field.hasWarnings(fieldFeedbacks.key)) ||\n      (fieldFeedbacks.props.stop === 'first-info' && field.hasInfos(fieldFeedbacks.key))\n    ) {\n      // Do nothing\n      validation.show = undefined; // undefined means the FieldFeedback was not checked\n    } else {\n      validation.show = false;\n\n      if (typeof when === 'function') {\n        validation.show = when(input.value);\n      } else if (typeof when === 'string') {\n        if (when === 'valid') {\n          // undefined => special case for when=\"valid\": always displayed, then FieldFeedbackWhenValid decides what to do\n          validation.show = undefined;\n        } else {\n          const { validity } = input;\n\n          if (!validity.valid) {\n            if (when === '*') {\n              validation.show = true;\n            } else if (\n              (validity.badInput && when === 'badInput') ||\n              (validity.patternMismatch && when === 'patternMismatch') ||\n              (validity.rangeOverflow && when === 'rangeOverflow') ||\n              (validity.rangeUnderflow && when === 'rangeUnderflow') ||\n              (validity.stepMismatch && when === 'stepMismatch') ||\n              (validity.tooLong && when === 'tooLong') ||\n              (validity.tooShort && when === 'tooShort') ||\n              (validity.typeMismatch && when === 'typeMismatch') ||\n              (validity.valueMissing && when === 'valueMissing')\n            ) {\n              validation.show = true;\n            }\n          }\n        }\n      } else {\n        throw new TypeError(`Invalid FieldFeedback 'when' type: ${typeof when}`);\n      }\n    }\n\n    field.addOrReplaceValidation(validation);\n\n    this.setState({\n      validation,\n      validationMessage: input.validationMessage\n    });\n\n    return validation;\n  };\n\n  fieldDidReset = (field: Field) => {\n    // Ignore the event if it's not for us\n    // eslint-disable-next-line react/destructuring-assignment\n    if (field.name === this.context.fieldFeedbacks.fieldName) {\n      this.setState(prevState => ({\n        validation: { ...prevState.validation, ...{ show: undefined } },\n        validationMessage: ''\n      }));\n    }\n  };\n\n  // Don't forget to update native/FieldFeedback.render()\n  render() {\n    const { when, error, warning, info, className, classes, style, children, ...otherProps } = (this\n      .props as unknown) as FieldFeedbackProps;\n    const { validation, validationMessage } = this.state;\n\n    const fieldFeedbackClassName = classes![validation.type]!;\n    const classNames =\n      className !== undefined ? `${className} ${fieldFeedbackClassName}` : fieldFeedbackClassName;\n\n    // Special case for when=\"valid\": always displayed, then FieldFeedbackWhenValid decides what to do\n    if (validation.type === FieldFeedbackType.WhenValid) {\n      return (\n        <FieldFeedbackWhenValid\n          data-feedback={this.key}\n          style={style}\n          className={classNames}\n          {...otherProps}\n        >\n          {children}\n        </FieldFeedbackWhenValid>\n      );\n    }\n\n    if (validation.show) {\n      const feedback = children !== undefined ? children : validationMessage;\n\n      // <span style=\"display: block\"> instead of <div> so FieldFeedback can be wrapped inside a <p>\n      return (\n        <span\n          data-feedback={this.key}\n          className={classNames}\n          style={{ display: 'block', ...style }}\n          {...otherProps}\n        >\n          {feedback}\n        </span>\n      );\n    }\n\n    return null;\n  }\n}\n","import * as React from 'react';\nimport * as PropTypes from 'prop-types';\n\nimport { Field } from './Field';\nimport { FormWithConstraints, FormWithConstraintsChildContext } from './FormWithConstraints';\n\nexport interface InputProps extends React.InputHTMLAttributes<HTMLInputElement> {\n  innerRef?: React.Ref<HTMLInputElement>;\n  classes: {\n    [index: string]: string | undefined;\n    isPending?: string;\n    hasErrors?: string;\n    hasWarnings?: string;\n    hasInfos?: string;\n    isValid?: string;\n  };\n}\n\ninterface InputState {\n  field: undefined | 'pending' | Field;\n}\n\nexport type InputContext = FormWithConstraintsChildContext;\n\nexport class Input extends React.Component<InputProps, InputState> {\n  static contextTypes: React.ValidationMap<InputContext> = {\n    form: PropTypes.instanceOf(FormWithConstraints).isRequired\n  };\n  context!: InputContext;\n\n  static defaultProps: InputProps = {\n    classes: {\n      isPending: 'is-pending',\n      hasErrors: 'has-errors',\n      hasWarnings: 'has-warnings',\n      hasInfos: 'has-infos',\n      isValid: 'is-valid'\n    }\n  };\n\n  state: InputState = {\n    field: undefined\n  };\n\n  /* eslint-disable react/destructuring-assignment */\n\n  componentDidMount() {\n    this.context.form.addFieldWillValidateEventListener(this.fieldWillValidate);\n    this.context.form.addFieldDidValidateEventListener(this.fieldDidValidate);\n    this.context.form.addFieldDidResetEventListener(this.fieldDidReset);\n  }\n\n  componentWillUnmount() {\n    this.context.form.removeFieldWillValidateEventListener(this.fieldWillValidate);\n    this.context.form.removeFieldDidValidateEventListener(this.fieldDidValidate);\n    this.context.form.removeFieldDidResetEventListener(this.fieldDidReset);\n  }\n\n  fieldWillValidate = (fieldName: string) => {\n    // Ignore the event if it's not for us\n    if (fieldName === this.props.name) {\n      this.setState({ field: 'pending' });\n    }\n  };\n\n  fieldDidValidate = (field: Field) => {\n    // Ignore the event if it's not for us\n    if (field.name === this.props.name) {\n      this.setState({ field });\n    }\n  };\n\n  fieldDidReset = (field: Field) => {\n    // Ignore the event if it's not for us\n    if (field.name === this.props.name) {\n      this.setState({ field: undefined });\n    }\n  };\n\n  /* eslint-enable react/destructuring-assignment */\n\n  fieldValidationStates() {\n    const { field } = this.state;\n\n    const states = [];\n\n    if (field !== undefined) {\n      if (field === 'pending') {\n        states.push('isPending');\n      } else {\n        if (field.hasErrors()) states.push('hasErrors');\n        if (field.hasWarnings()) states.push('hasWarnings');\n        if (field.hasInfos()) states.push('hasInfos');\n        if (field.isValid()) states.push('isValid');\n      }\n    }\n\n    return states;\n  }\n\n  render() {\n    const { innerRef, className, classes, ...inputProps } = this.props;\n    const validationStates = this.fieldValidationStates();\n\n    let classNames = className;\n    validationStates.forEach(validationState => {\n      const tmp = classes![validationState];\n      if (tmp !== undefined) {\n        if (classNames !== undefined) {\n          classNames += ` ${tmp}`;\n        } else {\n          classNames = tmp;\n        }\n      }\n    });\n\n    return <input ref={innerRef} {...inputProps} className={classNames} />;\n  }\n}\n","import * as React from 'react';\n\n// Recursive React.Children.forEach()\n// Taken from https://github.com/fernandopasik/react-children-utilities/blob/v0.2.2/src/index.js#L68\nexport function deepForEach(\n  children: React.ReactNode,\n  fn: (child: React.ReactElement<any>) => void\n) {\n  React.Children.forEach(children, child => {\n    const element = child as React.ReactElement<any>;\n    if (element.props && element.props.children && typeof element.props.children === 'object') {\n      deepForEach(element.props.children, fn);\n    }\n    fn(element);\n  });\n}\n"],"names":["assert","condition","message","undefined","console","EventEmitter","eventName","_i","args","listeners","this","getListeners","ret","Array","forEach","listener","push","i","length","_b","_a","_c","get","has","set","includes","index","lastIndexOf","splice","delete","Map","FieldFeedbackType","Field","validation","validations","findIndex","_validation","key","array","pop","clearArray","type","fieldFeedbacksKey","some","fieldFeedback","startsWith","show","hasFeedbacksOfType","Error","Warning","Info","hasErrors","hasWarnings","hasInfos","name","FieldEvent","__extends","FieldsStore","fieldName","fields","filter","_field","newField","emitSync","Added","indexOf","Removed","every","field","isValid","hasFeedbacks","_this","validity","badInput","customError","patternMismatch","rangeOverflow","rangeUnderflow","stepMismatch","tooLong","tooShort","typeMismatch","valid","valueMissing","isHTMLInput","input","props","value","IValidityState","validationMessage","FieldDidResetEvent","withFieldDidResetEventEmitter","Base","ResetFieldEvenEmitter","fieldDidResetEventEmitter","addListener","removeListener","FieldDidValidateEvent","withFieldDidValidateEventEmitter","FieldDidValidateEventEmitter","fieldDidValidateEventEmitter","FieldWillValidateEvent","withFieldWillValidateEventEmitter","FieldWillValidateEventEmitter","fieldWillValidateEventEmitter","ValidateFieldEvent","withValidateFieldEventEmitter","ValidateFieldEventEmitter","validateFieldEventEmitter","emitAsync","React.PureComponent","FormWithConstraintsComponent","FormWithConstraints","form","fieldFeedbacksKeyCounter","inputsOrNames","_validateFields","validateFieldsWithoutFeedback","forceValidateFields","inputs","normalizeInputs","validateField","InputElement","nativeInput","fieldsStore","getField","element","clearValidations","emitFieldWillValidateEvent","emitValidateFieldEvent","arrayOfArrays","JSON","stringify","flat","Infinity","emitFieldDidValidateEvent","from","querySelectorAll","map","self","query","elements","el","resetFields","resetField","emitFieldDidResetEvent","React.createElement","ref","PropTypes.instanceOf","isRequired","FieldFeedbacksComponent","FieldFeedbacks","fieldFeedbacks","fieldFeedbackKeyCounter","computeFieldFeedbackKey","context","fieldFeedbacksParent","addField","addValidateFieldEventListener","validate","removeField","removeValidateFieldEventListener","children","stop","_super","_validate","computeFieldFeedbacksKey","for","Status","AsyncComponent","Async","async","setState","status","Pending","promise","Resolved","Rejected","e_1","state","None","pending","then","catch","React.Component","FieldFeedbackWhenValid","addFieldWillValidateEventListener","fieldWillValidate","addFieldDidValidateEventListener","fieldDidValidate","addFieldDidResetEventListener","fieldDidReset","removeFieldWillValidateEventListener","removeFieldDidValidateEventListener","removeFieldDidResetEventListener","style","otherProps","fieldIsValid","display","FieldFeedback","className","classes","fieldFeedbackClassName","classNames","WhenValid","feedback","when","error","warning","info","whenValid","TypeError","addOrReplaceValidation","prevState","addFieldFeedback","Input","states","innerRef","inputProps","validationStates","fieldValidationStates","validationState","tmp","isPending","deepForEach","fn","React.Children","child"],"mappings":"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"}